#;(Question 1)
(define (subst x y L)
  (cond ((null? L) L)
    ((eq? x (car L))(cons y (subst x y (cdr L))))
    (else(cons (car L) (subst x y (cdr L))))))

#;(Question 2)
(define (all-different? L)
  (cond ((null? L) #t)
    ((null?(filter(lambda (i)(eq? i (car L)))(cdr L)))#;(i acts like a counter in a loop)
     (and #t (all-different? (cdr L))))
    (else #f)))

#;(Question 3)
(define T
  '(13 (5 (1 () ()) (8 () (9 () ())))
    (22 (17 () ()) (25 () ()))))
(define (left T) (car (cdr T)))
(define (right T) (caddr T))
(define (val T) (car T))
(define (n-nodes T)
  (cond ((null? T) 0)
    (else (+ 1 (n-nodes(left T)) (n-nodes(right T))))))
(define (n-leaves T)
  (cond ((null? T) 0)
    ((and (null? (left T)) (null?(right T))) 1) #;(checks if right/left leaves are empty)
    (else ( + (n-leaves (left T)) (n-leaves (right T))))))
(define (height T)
  (cond ((null? T) 0)
    (else (+ 1 (max (height (left T))(height (right T)))))))#;(if left is > than right move through that node)
     #;(have to use max because max outputs a value while > outputs #t or #f and map > produces an error)
(define (postorder T)
  (cond ((null? T) '())
    (else (append (postorder (left T)) (postorder (right T)) (list (val T)))))) 
     #;(concats the left nodes(1st) then the right(2nd) and finally the  root val(val T))

#;(Question 4)
(define (flatten L)
  (cond ((null? L) '())
    ((not(list? L))(list L))
    (else (append (flatten (car L))(flatten (cdr L))))))